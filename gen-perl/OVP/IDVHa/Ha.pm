#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use OVP::IDVHa::Types;

# HELPER FUNCTIONS AND STRUCTURES

package OVP::IDVHa::Ha_prepared_args;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_prepared_args->mk_accessors( qw( disk ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{disk} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{disk}) {
      $self->{disk} = $vals->{disk};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_prepared_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{disk} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new OVP::IDVHa::DiskInfo();
            $xfer += $elem5->read($input);
            push(@{$self->{disk}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_prepared_args');
  if (defined $self->{disk}) {
    $xfer += $output->writeFieldBegin('disk', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{disk}}));
      {
        foreach my $iter6 (@{$self->{disk}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_prepared_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_prepared_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_prepared_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size7 = 0;
          $self->{success} = {};
          my $_ktype8 = 0;
          my $_vtype9 = 0;
          $xfer += $input->readMapBegin(\$_ktype8, \$_vtype9, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $key12 = '';
            my $val13 = 0;
            $xfer += $input->readString(\$key12);
            $xfer += $input->readI32(\$val13);
            $self->{success}->{$key12} = $val13;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_prepared_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter14,$viter15) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter14);
          $xfer += $output->writeI32($viter15);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_created_with_others_args;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_created_with_others_args->mk_accessors( qw( ip1 ip2 ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ip1} = undef;
  $self->{ip2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ip1}) {
      $self->{ip1} = $vals->{ip1};
    }
    if (defined $vals->{ip2}) {
      $self->{ip2} = $vals->{ip2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_created_with_others_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ip1});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ip2});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_created_with_others_args');
  if (defined $self->{ip1}) {
    $xfer += $output->writeFieldBegin('ip1', TType::STRING, 1);
    $xfer += $output->writeString($self->{ip1});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ip2}) {
    $xfer += $output->writeFieldBegin('ip2', TType::STRING, 2);
    $xfer += $output->writeString($self->{ip2});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_created_with_others_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_created_with_others_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_created_with_others_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_created_with_others_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_setup_args;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_setup_args->mk_accessors( qw( net drbd is_master is_force ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{net} = undef;
  $self->{drbd} = undef;
  $self->{is_master} = undef;
  $self->{is_force} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{net}) {
      $self->{net} = $vals->{net};
    }
    if (defined $vals->{drbd}) {
      $self->{drbd} = $vals->{drbd};
    }
    if (defined $vals->{is_master}) {
      $self->{is_master} = $vals->{is_master};
    }
    if (defined $vals->{is_force}) {
      $self->{is_force} = $vals->{is_force};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_setup_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{net} = new OVP::IDVHa::NetInfo();
        $xfer += $self->{net}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{drbd} = new OVP::IDVHa::DrbdInfo();
        $xfer += $self->{drbd}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_master});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_force});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_setup_args');
  if (defined $self->{net}) {
    $xfer += $output->writeFieldBegin('net', TType::STRUCT, 1);
    $xfer += $self->{net}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{drbd}) {
    $xfer += $output->writeFieldBegin('drbd', TType::STRUCT, 2);
    $xfer += $self->{drbd}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{is_master}) {
    $xfer += $output->writeFieldBegin('is_master', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{is_master});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{is_force}) {
    $xfer += $output->writeFieldBegin('is_force', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{is_force});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_setup_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_setup_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_setup_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_setup_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_modify_args;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_modify_args->mk_accessors( qw( net is_master ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{net} = undef;
  $self->{is_master} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{net}) {
      $self->{net} = $vals->{net};
    }
    if (defined $vals->{is_master}) {
      $self->{is_master} = $vals->{is_master};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_modify_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{net} = new OVP::IDVHa::NetInfo();
        $xfer += $self->{net}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_master});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_modify_args');
  if (defined $self->{net}) {
    $xfer += $output->writeFieldBegin('net', TType::STRUCT, 1);
    $xfer += $self->{net}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{is_master}) {
    $xfer += $output->writeFieldBegin('is_master', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{is_master});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_modify_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_modify_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_modify_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_modify_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_remove_args;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_remove_args->mk_accessors( qw( is_master ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{is_master} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{is_master}) {
      $self->{is_master} = $vals->{is_master};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_remove_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{is_master});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_remove_args');
  if (defined $self->{is_master}) {
    $xfer += $output->writeFieldBegin('is_master', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{is_master});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_remove_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_remove_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_remove_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_remove_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_report_disk_error_info_args;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_report_disk_error_info_args->mk_accessors( qw( disk ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{disk} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{disk}) {
      $self->{disk} = $vals->{disk};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_report_disk_error_info_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size16 = 0;
          $self->{disk} = [];
          my $_etype19 = 0;
          $xfer += $input->readListBegin(\$_etype19, \$_size16);
          for (my $_i20 = 0; $_i20 < $_size16; ++$_i20)
          {
            my $elem21 = undef;
            $elem21 = new OVP::IDVHa::DiskInfo();
            $xfer += $elem21->read($input);
            push(@{$self->{disk}},$elem21);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_report_disk_error_info_args');
  if (defined $self->{disk}) {
    $xfer += $output->writeFieldBegin('disk', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{disk}}));
      {
        foreach my $iter22 (@{$self->{disk}}) 
        {
          $xfer += ${iter22}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_report_disk_error_info_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_report_disk_error_info_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_report_disk_error_info_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_report_disk_error_info_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_drbd_health_check_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_drbd_health_check_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_drbd_health_check_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_drbd_health_check_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_drbd_health_check_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_drbd_health_check_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_drbd_health_check_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_idv_service_check_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_idv_service_check_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_idv_service_check_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_idv_service_check_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_idv_service_check_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_idv_service_check_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_idv_service_check_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_net_health_check_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_net_health_check_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_net_health_check_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_net_health_check_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_net_health_check_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_net_health_check_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_net_health_check_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_switch_master_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_switch_master_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_switch_master_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_switch_master_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_switch_master_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_switch_master_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_switch_backup_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_switch_backup_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_switch_backup_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_switch_backup_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_switch_backup_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_switch_backup_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_switch_faults_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_switch_faults_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_switch_faults_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_switch_faults_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_switch_faults_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_switch_faults_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_ready_to_sync_args;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_ready_to_sync_args->mk_accessors( qw( res_num ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{res_num} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{res_num}) {
      $self->{res_num} = $vals->{res_num};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_ready_to_sync_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{res_num});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_ready_to_sync_args');
  if (defined $self->{res_num}) {
    $xfer += $output->writeFieldBegin('res_num', TType::I32, 1);
    $xfer += $output->writeI32($self->{res_num});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_ready_to_sync_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_ready_to_sync_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_ready_to_sync_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_ready_to_sync_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_get_ha_info_args;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_get_ha_info_args->mk_accessors( qw( local_ip ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{local_ip} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{local_ip}) {
      $self->{local_ip} = $vals->{local_ip};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_get_ha_info_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{local_ip});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_get_ha_info_args');
  if (defined $self->{local_ip}) {
    $xfer += $output->writeFieldBegin('local_ip', TType::STRING, 1);
    $xfer += $output->writeString($self->{local_ip});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_get_ha_info_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_get_ha_info_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_get_ha_info_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size23 = 0;
          $self->{success} = [];
          my $_etype26 = 0;
          $xfer += $input->readListBegin(\$_etype26, \$_size23);
          for (my $_i27 = 0; $_i27 < $_size23; ++$_i27)
          {
            my $elem28 = undef;
            {
              my $_size29 = 0;
              $elem28 = {};
              my $_ktype30 = 0;
              my $_vtype31 = 0;
              $xfer += $input->readMapBegin(\$_ktype30, \$_vtype31, \$_size29);
              for (my $_i33 = 0; $_i33 < $_size29; ++$_i33)
              {
                my $key34 = '';
                my $val35 = '';
                $xfer += $input->readString(\$key34);
                $xfer += $input->readString(\$val35);
                $elem28->{$key34} = $val35;
              }
              $xfer += $input->readMapEnd();
            }
            push(@{$self->{success}},$elem28);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_get_ha_info_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::MAP, scalar(@{$self->{success}}));
      {
        foreach my $iter36 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{${iter36}}));
            {
              while( my ($kiter37,$viter38) = each %{${iter36}}) 
              {
                $xfer += $output->writeString($kiter37);
                $xfer += $output->writeString($viter38);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_get_hostname_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_get_hostname_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_get_hostname_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_get_hostname_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_get_hostname_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_get_hostname_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_get_hostname_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_get_drbd_state_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_get_drbd_state_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_get_drbd_state_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::Ha_get_drbd_state_result;
use base qw(Class::Accessor);
OVP::IDVHa::Ha_get_drbd_state_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Ha_get_drbd_state_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size39 = 0;
          $self->{success} = [];
          my $_etype42 = 0;
          $xfer += $input->readListBegin(\$_etype42, \$_size39);
          for (my $_i43 = 0; $_i43 < $_size39; ++$_i43)
          {
            my $elem44 = undef;
            {
              my $_size45 = 0;
              $elem44 = {};
              my $_ktype46 = 0;
              my $_vtype47 = 0;
              $xfer += $input->readMapBegin(\$_ktype46, \$_vtype47, \$_size45);
              for (my $_i49 = 0; $_i49 < $_size45; ++$_i49)
              {
                my $key50 = '';
                my $val51 = '';
                $xfer += $input->readString(\$key50);
                $xfer += $input->readString(\$val51);
                $elem44->{$key50} = $val51;
              }
              $xfer += $input->readMapEnd();
            }
            push(@{$self->{success}},$elem44);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Ha_get_drbd_state_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::MAP, scalar(@{$self->{success}}));
      {
        foreach my $iter52 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{${iter52}}));
            {
              while( my ($kiter53,$viter54) = each %{${iter52}}) 
              {
                $xfer += $output->writeString($kiter53);
                $xfer += $output->writeString($viter54);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package OVP::IDVHa::HaIf;

use strict;


sub prepared{
  my $self = shift;
  my $disk = shift;

  die 'implement interface';
}

sub created_with_others{
  my $self = shift;
  my $ip1 = shift;
  my $ip2 = shift;

  die 'implement interface';
}

sub setup{
  my $self = shift;
  my $net = shift;
  my $drbd = shift;
  my $is_master = shift;
  my $is_force = shift;

  die 'implement interface';
}

sub modify{
  my $self = shift;
  my $net = shift;
  my $is_master = shift;

  die 'implement interface';
}

sub remove{
  my $self = shift;
  my $is_master = shift;

  die 'implement interface';
}

sub report_disk_error_info{
  my $self = shift;
  my $disk = shift;

  die 'implement interface';
}

sub drbd_health_check{
  my $self = shift;

  die 'implement interface';
}

sub idv_service_check{
  my $self = shift;

  die 'implement interface';
}

sub net_health_check{
  my $self = shift;

  die 'implement interface';
}

sub switch_master{
  my $self = shift;

  die 'implement interface';
}

sub switch_backup{
  my $self = shift;

  die 'implement interface';
}

sub switch_faults{
  my $self = shift;

  die 'implement interface';
}

sub ready_to_sync{
  my $self = shift;
  my $res_num = shift;

  die 'implement interface';
}

sub get_ha_info{
  my $self = shift;
  my $local_ip = shift;

  die 'implement interface';
}

sub get_hostname{
  my $self = shift;

  die 'implement interface';
}

sub get_drbd_state{
  my $self = shift;

  die 'implement interface';
}

package OVP::IDVHa::HaRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub prepared{
  my ($self, $request) = @_;

  my $disk = ($request->{'disk'}) ? $request->{'disk'} : undef;
  return $self->{impl}->prepared($disk);
}

sub created_with_others{
  my ($self, $request) = @_;

  my $ip1 = ($request->{'ip1'}) ? $request->{'ip1'} : undef;
  my $ip2 = ($request->{'ip2'}) ? $request->{'ip2'} : undef;
  return $self->{impl}->created_with_others($ip1, $ip2);
}

sub setup{
  my ($self, $request) = @_;

  my $net = ($request->{'net'}) ? $request->{'net'} : undef;
  my $drbd = ($request->{'drbd'}) ? $request->{'drbd'} : undef;
  my $is_master = ($request->{'is_master'}) ? $request->{'is_master'} : undef;
  my $is_force = ($request->{'is_force'}) ? $request->{'is_force'} : undef;
  return $self->{impl}->setup($net, $drbd, $is_master, $is_force);
}

sub modify{
  my ($self, $request) = @_;

  my $net = ($request->{'net'}) ? $request->{'net'} : undef;
  my $is_master = ($request->{'is_master'}) ? $request->{'is_master'} : undef;
  return $self->{impl}->modify($net, $is_master);
}

sub remove{
  my ($self, $request) = @_;

  my $is_master = ($request->{'is_master'}) ? $request->{'is_master'} : undef;
  return $self->{impl}->remove($is_master);
}

sub report_disk_error_info{
  my ($self, $request) = @_;

  my $disk = ($request->{'disk'}) ? $request->{'disk'} : undef;
  return $self->{impl}->report_disk_error_info($disk);
}

sub drbd_health_check{
  my ($self, $request) = @_;

  return $self->{impl}->drbd_health_check();
}

sub idv_service_check{
  my ($self, $request) = @_;

  return $self->{impl}->idv_service_check();
}

sub net_health_check{
  my ($self, $request) = @_;

  return $self->{impl}->net_health_check();
}

sub switch_master{
  my ($self, $request) = @_;

  return $self->{impl}->switch_master();
}

sub switch_backup{
  my ($self, $request) = @_;

  return $self->{impl}->switch_backup();
}

sub switch_faults{
  my ($self, $request) = @_;

  return $self->{impl}->switch_faults();
}

sub ready_to_sync{
  my ($self, $request) = @_;

  my $res_num = ($request->{'res_num'}) ? $request->{'res_num'} : undef;
  return $self->{impl}->ready_to_sync($res_num);
}

sub get_ha_info{
  my ($self, $request) = @_;

  my $local_ip = ($request->{'local_ip'}) ? $request->{'local_ip'} : undef;
  return $self->{impl}->get_ha_info($local_ip);
}

sub get_hostname{
  my ($self, $request) = @_;

  return $self->{impl}->get_hostname();
}

sub get_drbd_state{
  my ($self, $request) = @_;

  return $self->{impl}->get_drbd_state();
}

package OVP::IDVHa::HaClient;


use base qw(OVP::IDVHa::HaIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub prepared{
  my $self = shift;
  my $disk = shift;

    $self->send_prepared($disk);
  return $self->recv_prepared();
}

sub send_prepared{
  my $self = shift;
  my $disk = shift;

  $self->{output}->writeMessageBegin('prepared', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_prepared_args();
  $args->{disk} = $disk;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_prepared{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_prepared_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "prepared failed: unknown result";
}
sub created_with_others{
  my $self = shift;
  my $ip1 = shift;
  my $ip2 = shift;

    $self->send_created_with_others($ip1, $ip2);
  return $self->recv_created_with_others();
}

sub send_created_with_others{
  my $self = shift;
  my $ip1 = shift;
  my $ip2 = shift;

  $self->{output}->writeMessageBegin('created_with_others', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_created_with_others_args();
  $args->{ip1} = $ip1;
  $args->{ip2} = $ip2;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_created_with_others{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_created_with_others_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "created_with_others failed: unknown result";
}
sub setup{
  my $self = shift;
  my $net = shift;
  my $drbd = shift;
  my $is_master = shift;
  my $is_force = shift;

    $self->send_setup($net, $drbd, $is_master, $is_force);
  return $self->recv_setup();
}

sub send_setup{
  my $self = shift;
  my $net = shift;
  my $drbd = shift;
  my $is_master = shift;
  my $is_force = shift;

  $self->{output}->writeMessageBegin('setup', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_setup_args();
  $args->{net} = $net;
  $args->{drbd} = $drbd;
  $args->{is_master} = $is_master;
  $args->{is_force} = $is_force;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_setup{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_setup_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "setup failed: unknown result";
}
sub modify{
  my $self = shift;
  my $net = shift;
  my $is_master = shift;

    $self->send_modify($net, $is_master);
  return $self->recv_modify();
}

sub send_modify{
  my $self = shift;
  my $net = shift;
  my $is_master = shift;

  $self->{output}->writeMessageBegin('modify', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_modify_args();
  $args->{net} = $net;
  $args->{is_master} = $is_master;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_modify{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_modify_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "modify failed: unknown result";
}
sub remove{
  my $self = shift;
  my $is_master = shift;

    $self->send_remove($is_master);
  return $self->recv_remove();
}

sub send_remove{
  my $self = shift;
  my $is_master = shift;

  $self->{output}->writeMessageBegin('remove', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_remove_args();
  $args->{is_master} = $is_master;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_remove{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_remove_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "remove failed: unknown result";
}
sub report_disk_error_info{
  my $self = shift;
  my $disk = shift;

    $self->send_report_disk_error_info($disk);
  return $self->recv_report_disk_error_info();
}

sub send_report_disk_error_info{
  my $self = shift;
  my $disk = shift;

  $self->{output}->writeMessageBegin('report_disk_error_info', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_report_disk_error_info_args();
  $args->{disk} = $disk;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_report_disk_error_info{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_report_disk_error_info_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "report_disk_error_info failed: unknown result";
}
sub drbd_health_check{
  my $self = shift;

    $self->send_drbd_health_check();
  return $self->recv_drbd_health_check();
}

sub send_drbd_health_check{
  my $self = shift;

  $self->{output}->writeMessageBegin('drbd_health_check', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_drbd_health_check_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drbd_health_check{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_drbd_health_check_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "drbd_health_check failed: unknown result";
}
sub idv_service_check{
  my $self = shift;

    $self->send_idv_service_check();
  return $self->recv_idv_service_check();
}

sub send_idv_service_check{
  my $self = shift;

  $self->{output}->writeMessageBegin('idv_service_check', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_idv_service_check_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_idv_service_check{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_idv_service_check_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "idv_service_check failed: unknown result";
}
sub net_health_check{
  my $self = shift;

    $self->send_net_health_check();
  return $self->recv_net_health_check();
}

sub send_net_health_check{
  my $self = shift;

  $self->{output}->writeMessageBegin('net_health_check', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_net_health_check_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_net_health_check{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_net_health_check_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "net_health_check failed: unknown result";
}
sub switch_master{
  my $self = shift;

    $self->send_switch_master();
  $self->recv_switch_master();
}

sub send_switch_master{
  my $self = shift;

  $self->{output}->writeMessageBegin('switch_master', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_switch_master_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_switch_master{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_switch_master_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub switch_backup{
  my $self = shift;

    $self->send_switch_backup();
  $self->recv_switch_backup();
}

sub send_switch_backup{
  my $self = shift;

  $self->{output}->writeMessageBegin('switch_backup', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_switch_backup_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_switch_backup{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_switch_backup_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub switch_faults{
  my $self = shift;

    $self->send_switch_faults();
  $self->recv_switch_faults();
}

sub send_switch_faults{
  my $self = shift;

  $self->{output}->writeMessageBegin('switch_faults', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_switch_faults_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_switch_faults{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_switch_faults_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub ready_to_sync{
  my $self = shift;
  my $res_num = shift;

    $self->send_ready_to_sync($res_num);
  return $self->recv_ready_to_sync();
}

sub send_ready_to_sync{
  my $self = shift;
  my $res_num = shift;

  $self->{output}->writeMessageBegin('ready_to_sync', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_ready_to_sync_args();
  $args->{res_num} = $res_num;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_ready_to_sync{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_ready_to_sync_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "ready_to_sync failed: unknown result";
}
sub get_ha_info{
  my $self = shift;
  my $local_ip = shift;

    $self->send_get_ha_info($local_ip);
  return $self->recv_get_ha_info();
}

sub send_get_ha_info{
  my $self = shift;
  my $local_ip = shift;

  $self->{output}->writeMessageBegin('get_ha_info', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_get_ha_info_args();
  $args->{local_ip} = $local_ip;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_ha_info{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_get_ha_info_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_ha_info failed: unknown result";
}
sub get_hostname{
  my $self = shift;

    $self->send_get_hostname();
  return $self->recv_get_hostname();
}

sub send_get_hostname{
  my $self = shift;

  $self->{output}->writeMessageBegin('get_hostname', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_get_hostname_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_hostname{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_get_hostname_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_hostname failed: unknown result";
}
sub get_drbd_state{
  my $self = shift;

    $self->send_get_drbd_state();
  return $self->recv_get_drbd_state();
}

sub send_get_drbd_state{
  my $self = shift;

  $self->{output}->writeMessageBegin('get_drbd_state', TMessageType::CALL, $self->{seqid});
  my $args = new OVP::IDVHa::Ha_get_drbd_state_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_drbd_state{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new OVP::IDVHa::Ha_get_drbd_state_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_drbd_state failed: unknown result";
}
package OVP::IDVHa::HaProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_prepared {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_prepared_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_prepared_result();
    $result->{success} = $self->{handler}->prepared($args->disk);
    $output->writeMessageBegin('prepared', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_created_with_others {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_created_with_others_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_created_with_others_result();
    $result->{success} = $self->{handler}->created_with_others($args->ip1, $args->ip2);
    $output->writeMessageBegin('created_with_others', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_setup {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_setup_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_setup_result();
    $result->{success} = $self->{handler}->setup($args->net, $args->drbd, $args->is_master, $args->is_force);
    $output->writeMessageBegin('setup', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_modify {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_modify_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_modify_result();
    $result->{success} = $self->{handler}->modify($args->net, $args->is_master);
    $output->writeMessageBegin('modify', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_remove {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_remove_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_remove_result();
    $result->{success} = $self->{handler}->remove($args->is_master);
    $output->writeMessageBegin('remove', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_report_disk_error_info {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_report_disk_error_info_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_report_disk_error_info_result();
    $result->{success} = $self->{handler}->report_disk_error_info($args->disk);
    $output->writeMessageBegin('report_disk_error_info', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drbd_health_check {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_drbd_health_check_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_drbd_health_check_result();
    $result->{success} = $self->{handler}->drbd_health_check();
    $output->writeMessageBegin('drbd_health_check', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_idv_service_check {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_idv_service_check_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_idv_service_check_result();
    $result->{success} = $self->{handler}->idv_service_check();
    $output->writeMessageBegin('idv_service_check', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_net_health_check {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_net_health_check_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_net_health_check_result();
    $result->{success} = $self->{handler}->net_health_check();
    $output->writeMessageBegin('net_health_check', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_switch_master {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_switch_master_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_switch_master_result();
    $self->{handler}->switch_master();
    $output->writeMessageBegin('switch_master', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_switch_backup {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_switch_backup_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_switch_backup_result();
    $self->{handler}->switch_backup();
    $output->writeMessageBegin('switch_backup', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_switch_faults {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_switch_faults_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_switch_faults_result();
    $self->{handler}->switch_faults();
    $output->writeMessageBegin('switch_faults', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_ready_to_sync {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_ready_to_sync_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_ready_to_sync_result();
    $result->{success} = $self->{handler}->ready_to_sync($args->res_num);
    $output->writeMessageBegin('ready_to_sync', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_ha_info {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_get_ha_info_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_get_ha_info_result();
    $result->{success} = $self->{handler}->get_ha_info($args->local_ip);
    $output->writeMessageBegin('get_ha_info', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_hostname {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_get_hostname_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_get_hostname_result();
    $result->{success} = $self->{handler}->get_hostname();
    $output->writeMessageBegin('get_hostname', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_drbd_state {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new OVP::IDVHa::Ha_get_drbd_state_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new OVP::IDVHa::Ha_get_drbd_state_result();
    $result->{success} = $self->{handler}->get_drbd_state();
    $output->writeMessageBegin('get_drbd_state', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
